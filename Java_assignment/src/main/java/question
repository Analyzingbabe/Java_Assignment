Question and answer

Question 1:    Is JVM platform independent? is Java platform independent?

 	Yes, Java is platform-independent but JVM is platform dependent.

JVM;-
In Java, the main point here is that the JVM depends on the operating system – so if you are running Mac OS X you will have a different JVM than if you are running Windows or some other operating system. This fact can be verified by trying to download the JVM for your particular machine – when trying to download it, you will be given a list of JVMs corresponding to different operating systems, and you will obviously pick whichever JVM is targeted for the operating system that you are running. 
JAVA:-
In the case of Java, it is the magic of Bytecode that makes it platform independent.

•	This adds to an important feature in the JAVA language termed as portability. Every system has its own JVM which gets installed automatically when the jdk software is installed. For every operating system separate JVM is available which is capable to read the .class file or byte code.



Question:  What are the scenarios to select instance variable, static variable and local variable?

Variable:-
Variable is a memory location name of the data.

•	The value stored in a variable can be changed during program execution.
•	A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.
•	In Java, all the variables must be declared before use.

Ex: Int data_name

1. Datatype: Type of data that can be stored in this variable. 
2. Data name: Name was given to the variable. 
In this way, a name can only be given to a memory location. It can be assigned values in two ways: 
•	Variable Initialization.     Ex Int A=10;
•	Assigning value by taking input.    Int a=2,b=2; int c; c=a+2;


Types of Variables in Java
1.	Local Variables
2.	Instance Variables
3.	Static Variables
4.	


Local Variables
	Instance Variables
	Static Variables

1.A variable defined within a block or method or constructor is called a local variable. 
	Instance variables are non-static variables and are declared in a class outside any method, constructor, or block. 
	Static variables are also known as Class variables

2. Ex
int var = 10; // Declared a Local Variable
        
   System.out.println("Local Variable: " + var);
Output:
Local Variable 10
	Ex
public String geek; // Declared Instance Variable
 
    public GFG()
    { // Default Constructor
 

 { this.geek = "Jain"; // initializing Instance Variable}
//Main Method
    public static void main(String[] args)
    {
        // Object Creation
        GFG name = new GFG();
        // Displaying O/P
        System.out.println("Geek name is: " + name.geek);
    }
}
Output:
Geek name is: Jain
	Ex
class GFG {
  public static String geek = "Jain";         //Declared static variable
   
    public static void main (String[] args) {
        
      //geek variable can be accessed with object creation
      //Displaying O/P
      //GFG.geek --> using the static variable
        System.out.println("Geek Name is : "+GFG.geek);
    }
}
Output:
Geek name is: Jain




Question 3: What’s the difference between literal approach and new keyword approach of String object creation?
			

String creation using new()	String creation using String literal
If we create a String using new(), then a new object is created in the heap memory even if that value is already present in the heap memory.	If we create a String using String literal and its value already exists in the string pool, then that String variable also points to that same value in the String pool without the creation of a new String with that value.
It takes more time for the execution and thus has lower performance than using String literal.	It takes less time for the execution and thus has better performance than using new().
Example:
String n1= new String(“Java”);
String n2= new String(“Java”);
String n3= new String(“Create”);	Example:
String s1=”Java”;
String s2=”Java”;
String s3=”Create”;


                 Stack	 String constant  Memory(SCM)
                   s1	1000-String object(Java)
                  s2	1000-String object(Java)
                  s3	1001-String object(Create)

                Stack	       Heap memory
                 n1	3000-string object(Java)
                 n2	3001-string object(Java)
                 n3	3002-string object(Create)





Programs:-
{
    public static void main(String[] args)
    {
        String s1="Java";
        String s2="Java";
        String s3="Create";

        String n1= new String("Java");
        String n2= new String("Java");
        String n3= new String("Create");

        System.out.println(s1==s2);
        System.out.println(n1==n2);
        System.out.println(s3==n3);
    }
}

Output:-
true
false
false

Question4:  Whats difference between == operator and equals() ?

equals()	==
1. It is a method	It is a operator
2.Content comparision	Address & Content comparision
3.It compares two content if it is same, it returns true.	It compares two operands and memory location if both same then it returns true.
4.Overriding is allowed	Overriding not allowed

Program:-

public class Test {
    public static void main(String[] args)
    {
        String s1 = "HELLO";
        String s2 = "HELLO";
        String s3 =  new String("HELLO");
 
        System.out.println(s1 == s2); // true
        System.out.println(s1 == s3); // false
        System.out.println(s1.equals(s2)); // true
        System.out.println(s1.equals(s3)); // true
    }
}


Output:-
true.   //checks address and content
false.  // checks address and content
true. //check only content
true.   //checks only content



Question5:  Is String mutable?


String is an example of an immutable type. A String object always represents the same string. StringBuilder is an example of a mutable type. It has methods to delete parts of the string, insert or replace characters, etc.

Since String is immutable, once created, a String object always has the same value. To add something to the end of a String, you have to create a new String object:
Example:-
String s = "a";
s = s.concat("b"); // s+="b" and s=s+"b" also mean the same thing
